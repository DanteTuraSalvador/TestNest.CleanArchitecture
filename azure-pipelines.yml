trigger:
  branches:
    include:
      - master
      - develop
      - feature/*
  paths:
    exclude:
      - README.md
      - docs/*
      - .gitignore

pr:
  branches:
    include:
      - master
      - develop
  paths:
    exclude:
      - README.md
      - docs/*
      - .gitignore

pool:
  vmImage: 'windows-latest'

variables:
  buildConfiguration: 'Release'
  solution: '**/*.sln'
  projects: '**/*.csproj'
  testProjects: '**/*Tests.csproj'
  dotnetVersion: '9.x'
  dockerRegistryServiceConnection: 'TestNestACR'
  imageRepository: 'testnest-admin-api'
  containerRegistry: 'testnestregistry.azurecr.io'
  dockerfilePath: '$(Build.SourcesDirectory)/Dockerfile'
  tag: '$(Build.BuildId)'

stages:
  - stage: Build
    displayName: 'Build and Test'
    jobs:
      - job: BuildAndTest
        displayName: 'Build and Test Job'
        steps:
          # Install .NET SDK
          - task: UseDotNet@2
            displayName: 'Install .NET SDK'
            inputs:
              version: $(dotnetVersion)
              includePreviewVersions: false

          # Restore NuGet packages
          - task: DotNetCoreCLI@2
            displayName: 'Restore NuGet Packages'
            inputs:
              command: 'restore'
              projects: $(solution)
              feedsToUse: 'select'
              verbosityRestore: 'Minimal'

          # Build solution
          - task: DotNetCoreCLI@2
            displayName: 'Build Solution'
            inputs:
              command: 'build'
              projects: $(solution)
              arguments: '--configuration $(buildConfiguration) --no-restore'

          # Run tests with code coverage
          - task: DotNetCoreCLI@2
            displayName: 'Run Tests with Coverage'
            inputs:
              command: 'test'
              projects: $(testProjects)
              arguments: '--configuration $(buildConfiguration) --no-build --collect:"XPlat Code Coverage" --results-directory $(Agent.TempDirectory)/TestResults --logger trx'
              publishTestResults: true

          # Publish code coverage results
          - task: PublishCodeCoverageResults@2
            displayName: 'Publish Code Coverage'
            inputs:
              summaryFileLocation: '$(Agent.TempDirectory)/TestResults/**/coverage.cobertura.xml'
              codecoverageTool: 'Cobertura'
              failIfCoverageEmpty: false

          # Publish test results
          - task: PublishTestResults@2
            displayName: 'Publish Test Results'
            condition: succeededOrFailed()
            inputs:
              testResultsFormat: 'VSTest'
              testResultsFiles: '$(Agent.TempDirectory)/TestResults/**/*.trx'
              mergeTestResults: true
              failTaskOnFailedTests: true
              testRunTitle: 'TestNest.Admin Tests'

          # Publish build artifacts
          - task: DotNetCoreCLI@2
            displayName: 'Publish API'
            inputs:
              command: 'publish'
              publishWebProjects: false
              projects: '**/TestNest.Admin.API.csproj'
              arguments: '--configuration $(buildConfiguration) --output $(Build.ArtifactStagingDirectory)/api --no-build'
              zipAfterPublish: true
              modifyOutputPath: true

          # Upload build artifacts
          - task: PublishBuildArtifacts@1
            displayName: 'Upload Build Artifacts'
            inputs:
              PathtoPublish: '$(Build.ArtifactStagingDirectory)'
              ArtifactName: 'drop'
              publishLocation: 'Container'

  - stage: CodeQuality
    displayName: 'Code Quality Analysis'
    dependsOn: Build
    condition: succeeded()
    jobs:
      - job: CodeAnalysis
        displayName: 'Code Analysis Job'
        steps:
          # Install .NET SDK
          - task: UseDotNet@2
            displayName: 'Install .NET SDK'
            inputs:
              version: $(dotnetVersion)
              includePreviewVersions: false

          # Restore NuGet packages
          - task: DotNetCoreCLI@2
            displayName: 'Restore NuGet Packages'
            inputs:
              command: 'restore'
              projects: $(solution)
              feedsToUse: 'select'
              verbosityRestore: 'Minimal'

          # Build solution for analysis
          - task: DotNetCoreCLI@2
            displayName: 'Build Solution'
            inputs:
              command: 'build'
              projects: $(solution)
              arguments: '--configuration $(buildConfiguration) --no-restore'

  - stage: Docker
    displayName: 'Build and Push Docker Image'
    dependsOn: CodeQuality
    condition: and(succeeded(), or(eq(variables['Build.SourceBranch'], 'refs/heads/master'), eq(variables['Build.SourceBranch'], 'refs/heads/develop')))
    jobs:
      - job: BuildAndPushDocker
        displayName: 'Build and Push Docker Image'
        pool:
          vmImage: 'ubuntu-latest'
        steps:
          - task: Docker@2
            displayName: 'Build Docker Image'
            inputs:
              command: 'build'
              repository: $(imageRepository)
              dockerfile: $(dockerfilePath)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                $(tag)
                latest

          - task: Docker@2
            displayName: 'Push Docker Image to ACR'
            inputs:
              command: 'push'
              repository: $(imageRepository)
              containerRegistry: $(dockerRegistryServiceConnection)
              tags: |
                $(tag)
                latest

          - task: PowerShell@2
            displayName: 'Display Image Information'
            inputs:
              targetType: 'inline'
              script: |
                Write-Host "Docker image built and pushed successfully!"
                Write-Host "Repository: $(containerRegistry)/$(imageRepository)"
                Write-Host "Tags: $(tag), latest"
                Write-Host "Build ID: $(Build.BuildId)"
                Write-Host "Source Branch: $(Build.SourceBranch)"

  # Deployment Stages
  - stage: DeployDev
    displayName: 'Deploy to Dev'
    dependsOn: Docker
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/develop'))
    jobs:
      - deployment: DeployDevJob
        displayName: 'Deploy to Development Environment'
        environment: 'TestNest-Dev'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@1
                  displayName: 'Download Build Artifacts'
                  inputs:
                    buildType: 'current'
                    downloadType: 'single'
                    artifactName: 'drop'
                    downloadPath: '$(System.ArtifactsDirectory)'

                # Database Migration Steps
                - task: UseDotNet@2
                  displayName: 'Install .NET SDK for Migrations'
                  inputs:
                    version: $(dotnetVersion)
                    includePreviewVersions: false

                - task: DotNetCoreCLI@2
                  displayName: 'Install EF Core Tools'
                  inputs:
                    command: 'custom'
                    custom: 'tool'
                    arguments: 'install --global dotnet-ef --version 9.0.0'

                - task: PowerShell@2
                  displayName: 'Backup Database (Dev)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Creating database backup before migration..."
                      Write-Host "Backup timestamp: $(Get-Date -Format 'yyyy-MM-dd-HHmmss')"
                      # In production, implement actual backup using Azure SQL or similar
                      Write-Host "Backup completed (placeholder for actual backup implementation)"

                - task: PowerShell@2
                  displayName: 'Run Database Migrations (Dev)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Applying database migrations to Dev environment..."
                      $connectionString = "$(DevDatabaseConnectionString)"

                      # Extract and navigate to the Infrastructure project
                      Expand-Archive -Path "$(System.ArtifactsDirectory)/drop/api/*.zip" -DestinationPath "$(System.ArtifactsDirectory)/extracted" -Force

                      # Apply migrations
                      dotnet ef database update --project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.Infrastructure.dll" --startup-project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.API.dll" --connection "$connectionString" --verbose

                      if ($LASTEXITCODE -ne 0) {
                        Write-Error "Migration failed with exit code $LASTEXITCODE"
                        exit 1
                      }

                      Write-Host "Migrations applied successfully"

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy API to Azure App Service (Dev)'
                  inputs:
                    ConnectionType: 'AzureRM'
                    azureSubscription: '$(AzureServiceConnection)'
                    appType: 'webApp'
                    WebAppName: '$(DevWebAppName)'
                    packageForLinux: '$(System.ArtifactsDirectory)/drop/api/*.zip'
                    RuntimeStack: 'DOTNETCORE|8.0'

  - stage: DeployStaging
    displayName: 'Deploy to Staging'
    dependsOn: Docker
    condition: and(succeeded(), eq(variables['Build.SourceBranch'], 'refs/heads/master'))
    jobs:
      - deployment: DeployStagingJob
        displayName: 'Deploy to Staging Environment'
        environment: 'TestNest-Staging'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@1
                  displayName: 'Download Build Artifacts'
                  inputs:
                    buildType: 'current'
                    downloadType: 'single'
                    artifactName: 'drop'
                    downloadPath: '$(System.ArtifactsDirectory)'

                # Database Migration Steps
                - task: UseDotNet@2
                  displayName: 'Install .NET SDK for Migrations'
                  inputs:
                    version: $(dotnetVersion)
                    includePreviewVersions: false

                - task: DotNetCoreCLI@2
                  displayName: 'Install EF Core Tools'
                  inputs:
                    command: 'custom'
                    custom: 'tool'
                    arguments: 'install --global dotnet-ef --version 9.0.0'

                - task: PowerShell@2
                  displayName: 'Backup Database (Staging)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Creating database backup before migration..."
                      $backupName = "staging-backup-$(Get-Date -Format 'yyyy-MM-dd-HHmmss')"
                      Write-Host "Backup name: $backupName"
                      # In production, implement actual backup using Azure SQL backup
                      Write-Host "Backup completed (placeholder for actual backup implementation)"

                - task: PowerShell@2
                  displayName: 'Run Database Migrations (Staging)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Applying database migrations to Staging environment..."
                      $connectionString = "$(StagingDatabaseConnectionString)"

                      # Extract the deployment package
                      Expand-Archive -Path "$(System.ArtifactsDirectory)/drop/api/*.zip" -DestinationPath "$(System.ArtifactsDirectory)/extracted" -Force

                      # Apply migrations
                      dotnet ef database update --project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.Infrastructure.dll" --startup-project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.API.dll" --connection "$connectionString" --verbose

                      if ($LASTEXITCODE -ne 0) {
                        Write-Error "Migration failed with exit code $LASTEXITCODE"
                        Write-Error "Rolling back migration... (implement rollback strategy)"
                        exit 1
                      }

                      Write-Host "Migrations applied successfully"

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy API to Azure App Service (Staging)'
                  inputs:
                    ConnectionType: 'AzureRM'
                    azureSubscription: '$(AzureServiceConnection)'
                    appType: 'webApp'
                    WebAppName: '$(StagingWebAppName)'
                    packageForLinux: '$(System.ArtifactsDirectory)/drop/api/*.zip'
                    RuntimeStack: 'DOTNETCORE|8.0'

                - task: PowerShell@2
                  displayName: 'Run Smoke Tests'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $response = Invoke-WebRequest -Uri "https://$(StagingWebAppName).azurewebsites.net/health" -UseBasicParsing
                      if ($response.StatusCode -ne 200) {
                        Write-Error "Health check failed with status code: $($response.StatusCode)"
                        exit 1
                      }
                      Write-Host "Smoke test passed - Health check returned 200 OK"

  - stage: DeployProduction
    displayName: 'Deploy to Production'
    dependsOn: DeployStaging
    condition: succeeded()
    jobs:
      - deployment: DeployProductionJob
        displayName: 'Deploy to Production Environment'
        environment: 'TestNest-Production'
        strategy:
          runOnce:
            deploy:
              steps:
                - task: DownloadBuildArtifacts@1
                  displayName: 'Download Build Artifacts'
                  inputs:
                    buildType: 'current'
                    downloadType: 'single'
                    artifactName: 'drop'
                    downloadPath: '$(System.ArtifactsDirectory)'

                # Database Migration Steps with Enhanced Safety
                - task: UseDotNet@2
                  displayName: 'Install .NET SDK for Migrations'
                  inputs:
                    version: $(dotnetVersion)
                    includePreviewVersions: false

                - task: DotNetCoreCLI@2
                  displayName: 'Install EF Core Tools'
                  inputs:
                    command: 'custom'
                    custom: 'tool'
                    arguments: 'install --global dotnet-ef --version 9.0.0'

                - task: PowerShell@2
                  displayName: 'Create Production Database Backup'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Creating PRODUCTION database backup before migration..."
                      $backupName = "production-backup-$(Get-Date -Format 'yyyy-MM-dd-HHmmss')"
                      Write-Host "Backup name: $backupName"
                      Write-Host "CRITICAL: Implement Azure SQL automated backup verification"
                      Write-Host "Backup timestamp: $(Get-Date)"
                      # TODO: Implement actual Azure SQL backup using:
                      # - Azure SQL Database automated backups
                      # - Long-term retention (LTR) backups
                      # - Point-in-time restore capability
                      Write-Host "Backup completed (placeholder - implement actual backup)"

                - task: PowerShell@2
                  displayName: 'Validate Migrations (Production)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Validating pending migrations..."
                      $connectionString = "$(ProductionDatabaseConnectionString)"

                      # Extract the deployment package
                      Expand-Archive -Path "$(System.ArtifactsDirectory)/drop/api/*.zip" -DestinationPath "$(System.ArtifactsDirectory)/extracted" -Force

                      # Generate migration script for review
                      dotnet ef migrations script --project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.Infrastructure.dll" --startup-project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.API.dll" --idempotent --output "$(System.ArtifactsDirectory)/migration-script.sql"

                      Write-Host "Migration script generated at: $(System.ArtifactsDirectory)/migration-script.sql"
                      Write-Host "Script preview (first 50 lines):"
                      Get-Content "$(System.ArtifactsDirectory)/migration-script.sql" -TotalCount 50

                - task: PowerShell@2
                  displayName: 'Run Database Migrations (Production)'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Applying database migrations to PRODUCTION environment..."
                      $connectionString = "$(ProductionDatabaseConnectionString)"

                      # Apply migrations
                      dotnet ef database update --project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.Infrastructure.dll" --startup-project "$(System.ArtifactsDirectory)/extracted/TestNest.Admin.API.dll" --connection "$connectionString" --verbose

                      if ($LASTEXITCODE -ne 0) {
                        Write-Error "CRITICAL: Production migration failed with exit code $LASTEXITCODE"
                        Write-Error "Initiating rollback procedure..."
                        Write-Error "Contact database administrator immediately"
                        # TODO: Implement automated rollback using:
                        # - Azure SQL point-in-time restore
                        # - Migration rollback script
                        # - Database snapshot restore
                        exit 1
                      }

                      Write-Host "Production migrations applied successfully"
                      Write-Host "Migration completed at: $(Get-Date)"

                - task: AzureRmWebAppDeployment@4
                  displayName: 'Deploy API to Azure App Service (Production)'
                  inputs:
                    ConnectionType: 'AzureRM'
                    azureSubscription: '$(AzureServiceConnection)'
                    appType: 'webApp'
                    WebAppName: '$(ProductionWebAppName)'
                    packageForLinux: '$(System.ArtifactsDirectory)/drop/api/*.zip'
                    RuntimeStack: 'DOTNETCORE|8.0'

                - task: PowerShell@2
                  displayName: 'Run Smoke Tests'
                  inputs:
                    targetType: 'inline'
                    script: |
                      $response = Invoke-WebRequest -Uri "https://$(ProductionWebAppName).azurewebsites.net/health" -UseBasicParsing
                      if ($response.StatusCode -ne 200) {
                        Write-Error "Health check failed with status code: $($response.StatusCode)"
                        exit 1
                      }
                      Write-Host "Smoke test passed - Health check returned 200 OK"

                - task: PowerShell@2
                  displayName: 'Verify Database Integrity'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Verifying database integrity after migration..."
                      Write-Host "TODO: Implement database integrity checks"
                      Write-Host "- Verify all tables exist"
                      Write-Host "- Check critical data integrity"
                      Write-Host "- Validate foreign key constraints"
                      Write-Host "Database verification completed"

                - task: PowerShell@2
                  displayName: 'Send Deployment Notification'
                  inputs:
                    targetType: 'inline'
                    script: |
                      Write-Host "Deployment to Production completed successfully"
                      Write-Host "Build Number: $(Build.BuildNumber)"
                      Write-Host "Commit: $(Build.SourceVersion)"
                      Write-Host "Migration completed: $(Get-Date)"
